\subsection{Recolección de datos de aplicaciones}
\label{aplicaciones}

En  esta sección explicaremos cómo enviar datos de las aplicaciones \eng{web} a
\gls{term:influx}. Para enviar datos hemos usado la \gls{term:gema}
\texttt{influxdb-rails}. Esta \gls{term:gema} proporciona métodos para vincular
\gls{term:ror} con \gls{term:influx}.

Para que la aplicación \gls{term:ror} pueda hacer uso de estos métodos, es
necesario agregar la siguiente línea al archivo \texttt{Gemfile}:

\begin{lstlisting}
gem "influxdb-rails"
\end{lstlisting}

Una vez que tenemos instalada la \gls{term:gema}, podemos configurar el
adaptador \texttt{InfluxDB::Rails} en un archivo de configuración de la
aplicación. La configuración por defecto debería verse de la siguiente manera:

\begin{lstlisting}
InfluxDB::Rails.configure do |config|
  config.influxdb_database = "rails"
  config.influxdb_username = "root"
  config.influxdb_password = "root"
  config.influxdb_hosts    = ["influx"]
  config.influxdb_port     = 8086
end
\end{lstlisting}

El código ruby anterior configura los datos necesarios para que la aplicación
pueda comunicarse con la base de datos. Estos datos son el nombre de la base de
datos, el nombre de usuario, la contraseña del usuario y el nombre del
\gls{term:host} y el número de puerto por el cual comunicarse con la
\gls{term:api} de \gls{term:influx}.

Sin necesidad de configurar nada más, la \gls{term:gema} brinda automáticamente
reportes de los tiempos de ejecución de cada solicitud \eng{web} para los
controladores, las vistas y las bases de datos. Pero además, posibilita la
realización de llamadas al cliente \gls{term:influx} directamente, escribiendo
datos arbitrarios de la siguiente manera:

\begin{lstlisting}
InfluxDB::Rails.client.write_point "events",
  tags:   { url: "/ejemplo", user_id: 1 },
  values: { value: 0 }
\end{lstlisting}

A continuación mostraremos un ejemplo concreto de cómo se puede utilizar esta
herramienta para generar métricas útiles para el equipo de desarrollo y para
los dueños de un sistema:

La \gls{acro:unlp} cuenta con un sistema de acceso único, también conocido como
\gls{term:sso} que brinda el servicio de autenticación y autorización de todos
sus empleados en los distintos sistemas.

Este sistema consiste en una aplicación desarrollada en el framework
\gls{term:ror}. Esta aplicación ha estado funcionando desde hace
aproximadamente 2 años.

El \gls{term:sso} centraliza la información de todos los usuarios
pertenecientes a la universidad, evitando que sea necesario replicar dicha
información en distintas bases de datos. Además, mantiene información de las
aplicaciones a las que puede ingresar cada usuario, y el rol que cumplen los
usuarios en cada una de ellas.

Creemos que puede ser importante mantener un seguimiento de los inicios de
sesión de usuarios en las diferentes aplicaciones. Podemos utilizar la librería
\texttt{influxdb-rails} para cumplir este objetivo, escribiendo el siguiente
código \gls{term:ruby} para que sea ejecutado cada vez que un usuario inicia
sesión exitosamente:

\begin{lstlisting}
InfluxDB::Rails.client.write_point(
  "logins",
  tags:   { 
    ip: request.remote_ip,
    user_id: current_user.id,
    application: access.application
  },
  values: { value: request_time }
)
\end{lstlisting}

Las expresiones \lstinline{request.remote_ip} y \lstinline{current_user.id}
contienen respectivamente la dirección \gls{acro:ip} y el identificador único
del usuario que está iniciando sesión en alguno de los sistemas de la
\gls{acro:unlp}. La aplicación a la cual se quiere conectar el usuario es
obtenida a través de \lstinline{access.application}. El tiempo que demoró la
petición \eng{web} en resolverse lo encontramos en la variable
\lstinline{request_time}.

A partir de esta información que estamos enviando a \gls{term:influx}, es
posible obtener varias métricas que pueden ser útiles para los desarrolladores,
profesionales de IT y otros. Algunos ejemplos de estas métricas son:

\begin{itemize}
  \item Tiempo de respuesta promedio para la operación de inicio de sesión
  \item Cantidad de accesos por unidad de tiempo al servicio de autentificación
  \item Promedio de accesos a cada aplicación
  \item Accesos a cada aplicación agrupados por aplicación y franja horaria
\end{itemize}

Un usuario con un perfil gerencial podría verse beneficiado al hacer uso de
estas métricas. Por ejemplo, podría tomar la cantidad de accesos a servicios de
la Universidad agrupados por aplicación y descubrir cuáles son los servicios
más y menos utilizados.

Este tipo de información puede ayudar a guiar decisiones dentro de las
distintas áreas del \gls{acro:cespi}.

\gls{term:ror} incluye una \gls{term:api} de instrumentación
\footnote{\url{http://guides.rubyonrails.org/active_support_instrumentation.html}}
que sirve para medir eventos. Con esta \gls{term:api}, los desarrolladores
pueden elegir ser notificados cuando ciertas acciones ocurren dentro de las
aplicaciones.

La \gls{term:api} de instrumentación provee enganches, o \eng{hooks} a los
cuales los desarrolladores pueden suscribirse y así ser notificados en caso de
que determinados eventos se produzcan. De esta forma, se podrán tomar acciones
a partir de la ocurrencia de estos eventos. Además, la \gls{term:api} provee
herramientas para que un programador pueda crear sus propios \eng{hooks} a los
cuales subscribirse.

Por ejemplo, existe un \eng{hook} provisto por la librería de \gls{term:ror},
\eng{Active Record},
\footnote{\url{http://guides.rubyonrails.org/active_record_basics.html}} que es
llamado cada vez que se lleva a cabo una consulta SQL en una base de datos. Es
posible subscribirse a este \eng{hook}, y utilizarlo para tener un seguimiento
del número de consultas realizadas.

Podemos aprovechar las facilidades que provee la \gls{term:api} de
instrumentación de \gls{term:ror} para enviar a \gls{term:influx} información
sobre las consultas que se hacen a la base de datos, agregando las siguientes
líneas a un archivo de configuración:

\begin{lstlisting}
ActiveSupport::Notifications.subscribe("sql.active_record") do |name, start, finish, id, payload|
  InfluxDB::Rails.client.write_point name,
    value: (finish-start),
    start: start,
    finish: finish,
    name: name
end
\end{lstlisting}

La \gls{term:gema} \texttt{influxdb-rails} viene configurada por defecto para
apoyarse en el hook \lstinline{"process_action.action_controller"} y enviar a
\gls{term:influx} información sobre los tiempos de respuesta de cada petición
\eng{web}, distinguiendo el tiempo que demora en el renderizado de las vistas,
el procesamiento de los controladores y las consultas a las bases de datos.

Para ejecutar la aplicación \gls{term:ror} usando contenedores de
\gls{term:docker}, agregaremos el archivo Dockerfile en el directorio raíz de
la aplicación:

[ACA PODRÍAMOS USAR BIBLIOGRAFÍA]

\begin{lstlisting}
FROM ruby:2.3.1

RUN apt-get update -qq && apt-get install -y build-essential libpq-dev nodejs sqlite libsqlite3-dev

RUN mkdir /app

WORKDIR /app

COPY Gemfile Gemfile.lock ./
RUN gem install bundler && bundle install

COPY . ./

EXPOSE 3000

# Configure an entry point, so we don't need to specify 
# "bundle exec" for each of our commands.
ENTRYPOINT ["bundle", "exec"]

CMD ["rails", "server", "-b", "0.0.0.0"]
\end{lstlisting}

La línea \lstinline{FROM ruby:2.3.1} declara que el contenedor se basa en la
imagen de \gls{term:docker} de nombre \lstinline{ruby:2.3.1}. La siguiente
lìnea se ocupa de instalar las librerías necesarias para usar la aplicación
\gls{term:ror}.

Luego se crea la carpeta de la aplicación, se copian los archivos
\lstinline{Gemfile} y \lstinline{Gemfile.lock}, donde se describen las
dependencias de la aplicación, y se instalan las \glspl{term:gema} de esos
archivos con el comando \lstinline{bundle install}.

Finalmente, se copia el contenido de la aplicación al contenedor
\gls{term:docker}, se expone el puerto 3000, y se corre la aplicación con el
comando \lstinline{rails server -b 0.0.0.0}.

Mostraremos a continuación cómo podemos hacer para correr la aplicación al
mismo tiempo que ejecutamos sus servicios. Para esta tarea utilizaremos Compose
de \gls{term:docker}. Compose permite definir una configuración de los
servicios de una aplicación en un archivo, e iniciar todos estos servicios con
un sólo comando.

Hemos escrito una explicación un poco más detallada de Docker Compose en
\autoref{anexo_compose}.

El siguiente archivo \gls{term:docker} Compose es un ejemplo de cómo configurar
la aplicación \gls{term:ror} para trabajar con \gls{term:influx}.

\begin{lstlisting}
version: "2"
services:
  app:
    build: app
    command: rails server -p 3000 -b '0.0.0.0'
    volumes:
      - ./app/:/app
    ports:
      - "3000:3000"
    networks:
      - metricnet

  influxsrv:
    image: influxdb:1.0.0-rc1
    ports:
      - "8083:8083"
      - "8086:8086"
    expose:
      - "8090"
      - "8099"
    networks:
      - metricnet

networks:
  metricnet:
    driver: bridge
\end{lstlisting}

En el archivo se definen dos servicios. La aplicación \gls{term:ror} es el
servicio de nombre \lstinline{app}, y la base de datos \gls{term:influx} es el
servicio de nombre \lstinline{influx}. Ambos utilizan la red \lstinline{lognet}
para comunicarse entre sí.

\lstinline{app} usa el dockerfile que definimos anteriormente para inicializar
el servicio de la aplicación, y define los puertos externo e interno
\lstinline{3000:3000}.

\lstinline{influx} utiliza la imágen \lstinline{influxdb:1.0.0-rc1} y configura
algunas variables de ambiente, como lo son el nombre del usuario administrador,
la contraseña del usuario y el nombre de la base de datos a crear por defecto.
Finalmente define los puertos por donde estará la \gls{term:api} y el cliente
\eng{web}.
